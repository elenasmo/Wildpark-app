{"version":3,"file":"index.js","sources":["../../src/formatter/spacer.js","../../node_modules/is-plain-object/node_modules/isobject/index.js","../../node_modules/is-plain-object/index.js","../../node_modules/@base2/pretty-print-object/dist/index.js","../../src/formatter/sortObject.js","../../src/tree.js","../../src/parser/parseReactElement.js","../../src/formatter/formatFunction.js","../../src/formatter/formatComplexDataStructure.js","../../src/formatter/formatPropValue.js","../../src/formatter/formatProp.js","../../src/formatter/mergeSiblingPlainStringChildrenReducer.js","../../src/formatter/sortPropsByNames.js","../../src/formatter/formatReactElementNode.js","../../src/formatter/formatReactFragmentNode.js","../../src/formatter/formatTreeNode.js","../../src/formatter/formatTree.js","../../src/index.js"],"sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport default function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nimport isObject from 'isobject';\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport default function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar seen = [];\n/**\n * Check if a value is an object or a function. Keep in mind that array, function, regexp, etc, are objects in JavaScript.\n *\n * @param value the value to check\n * @return true if the value is an object or a function\n */\nfunction isObj(value) {\n    var type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n/**\n * Check if a value is a regular expression.\n *\n * @param value the value to check\n * @return true if the value is a regular expression\n */\nfunction isRegexp(value) {\n    return Object.prototype.toString.call(value) === '[object RegExp]';\n}\n/**\n * Get an array of all of the enumerable symbols for an object.\n *\n * @param object the object to get the enumerable symbols for\n */\nfunction getOwnEnumPropSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(function (keySymbol) { return Object.prototype.propertyIsEnumerable.call(object, keySymbol); });\n}\n/**\n * pretty print an object\n *\n * @param input the object to pretty print\n * @param options the formatting options, transforms, and filters\n * @param pad the padding string\n */\nfunction prettyPrint(input, options, pad) {\n    if (pad === void 0) { pad = ''; }\n    // sensible option defaults\n    var defaultOptions = {\n        indent: '\\t',\n        singleQuotes: true\n    };\n    var combinedOptions = __assign(__assign({}, defaultOptions), options);\n    var tokens;\n    if (combinedOptions.inlineCharacterLimit === undefined) {\n        tokens = {\n            newLine: '\\n',\n            newLineOrSpace: '\\n',\n            pad: pad,\n            indent: pad + combinedOptions.indent\n        };\n    }\n    else {\n        tokens = {\n            newLine: '@@__PRETTY_PRINT_NEW_LINE__@@',\n            newLineOrSpace: '@@__PRETTY_PRINT_NEW_LINE_OR_SPACE__@@',\n            pad: '@@__PRETTY_PRINT_PAD__@@',\n            indent: '@@__PRETTY_PRINT_INDENT__@@'\n        };\n    }\n    var expandWhiteSpace = function (string) {\n        if (combinedOptions.inlineCharacterLimit === undefined) {\n            return string;\n        }\n        var oneLined = string\n            .replace(new RegExp(tokens.newLine, 'g'), '')\n            .replace(new RegExp(tokens.newLineOrSpace, 'g'), ' ')\n            .replace(new RegExp(tokens.pad + '|' + tokens.indent, 'g'), '');\n        if (oneLined.length <= combinedOptions.inlineCharacterLimit) {\n            return oneLined;\n        }\n        return string\n            .replace(new RegExp(tokens.newLine + '|' + tokens.newLineOrSpace, 'g'), '\\n')\n            .replace(new RegExp(tokens.pad, 'g'), pad)\n            .replace(new RegExp(tokens.indent, 'g'), pad + combinedOptions.indent);\n    };\n    if (seen.indexOf(input) !== -1) {\n        return '\"[Circular]\"';\n    }\n    if (input === null ||\n        input === undefined ||\n        typeof input === 'number' ||\n        typeof input === 'boolean' ||\n        typeof input === 'function' ||\n        typeof input === 'symbol' ||\n        isRegexp(input)) {\n        return String(input);\n    }\n    if (input instanceof Date) {\n        return \"new Date('\" + input.toISOString() + \"')\";\n    }\n    if (Array.isArray(input)) {\n        if (input.length === 0) {\n            return '[]';\n        }\n        seen.push(input);\n        var ret = '[' + tokens.newLine + input.map(function (el, i) {\n            var eol = input.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n            var value = prettyPrint(el, combinedOptions, pad + combinedOptions.indent);\n            if (combinedOptions.transform) {\n                value = combinedOptions.transform(input, i, value);\n            }\n            return tokens.indent + value + eol;\n        }).join('') + tokens.pad + ']';\n        seen.pop();\n        return expandWhiteSpace(ret);\n    }\n    if (isObj(input)) {\n        var objKeys_1 = __spreadArrays(Object.keys(input), (getOwnEnumPropSymbols(input)));\n        if (combinedOptions.filter) {\n            objKeys_1 = objKeys_1.filter(function (el) { return combinedOptions.filter && combinedOptions.filter(input, el); });\n        }\n        if (objKeys_1.length === 0) {\n            return '{}';\n        }\n        seen.push(input);\n        var ret = '{' + tokens.newLine + objKeys_1.map(function (el, i) {\n            var eol = objKeys_1.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n            var isSymbol = typeof el === 'symbol';\n            var isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el.toString());\n            var key = isSymbol || isClassic ? el : prettyPrint(el, combinedOptions);\n            var value = prettyPrint(input[el], combinedOptions, pad + combinedOptions.indent);\n            if (combinedOptions.transform) {\n                value = combinedOptions.transform(input, el, value);\n            }\n            return tokens.indent + String(key) + ': ' + value + eol;\n        }).join('') + tokens.pad + '}';\n        seen.pop();\n        return expandWhiteSpace(ret);\n    }\n    input = String(input).replace(/[\\r\\n]/g, function (x) { return x === '\\n' ? '\\\\n' : '\\\\r'; });\n    if (!combinedOptions.singleQuotes) {\n        input = input.replace(/\"/g, '\\\\\"');\n        return \"\\\"\" + input + \"\\\"\";\n    }\n    input = input.replace(/\\\\?'/g, '\\\\\\'');\n    return \"'\" + input + \"'\";\n}\nexports.prettyPrint = prettyPrint;\n//# sourceMappingURL=index.js.map","/* @flow */\n\nexport default function sortObject(value: any): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date and regexp values as is\n  if (value instanceof Date || value instanceof RegExp) {\n    return value;\n  }\n\n  // make a copy of array with each item passed through sortObject()\n  if (Array.isArray(value)) {\n    return value.map(sortObject);\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current') {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = sortObject(value[key]);\n      }\n      return result;\n    }, {});\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getReactElementDisplayName = (element: ReactElement<*>): string =>\n  element.type.displayName ||\n  element.type.name || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport isPlainObject from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  Object.keys(props)\n    .filter(propName => filterProps.indexOf(propName) === -1)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(defaultPropName => filterProps.indexOf(defaultPropName) === -1)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(\\S*)(\\s*)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s*)(\\S*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"],"names":["times","tabStop","Array","fill","join","this","sortObject","value","Date","RegExp","isArray","map","Object","keys","sort","reduce","result","key","createStringTreeNode","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","Fragment","getReactElementDisplayName","element","type","name","noChildren","propsValue","propName","onlyMeaningfulChildren","children","filterProps","originalProps","cb","filteredProps","filter","forEach","parseReactElement","options","displayNameFn","React","isValidElement","Error","ref","search","Children","toArray","child","noRefCheck","inlineFunction","fn","toString","split","line","trim","preserveFunctionLineBreak","defaultFunctionValue","functionValue","showFunctions","inline","lvl","normalizedValue","stringifiedValue","prettyPrint","currentObj","prop","originalResult","currentValue","formatTreeNode","formatFunction","replace","spacer","escape","s","formatPropValue","propValue","String","symbolDescription","valueOf","toISOString","isPlainObject","formatComplexDataStructure","hasValue","hasDefaultValue","defaultValue","usedValue","useBooleanShorthandSyntax","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","includes","previousNodes","currentNode","nodes","slice","length","previousNode","push","isKeyOrRefProps","shouldSortUserProps","haveKeyProp","haveRefProp","userPropsOnly","oneProp","sortedProps","unshift","compensateMultilineStringElementIndentation","formattedElement","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","maxInlineAttributesLineLength","shouldRenderMultilineAttr","containsMultilineAttr","node","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","visibleAttributeNames","indexOf","defaultPropName","sortPropsByNames","formatProp","attributeName","newLvl","mergeSiblingPlainStringChildrenReducer","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","hasNoChildren","useFragmentShortSyntax","formatReactElementNode","jsxStopChars","shouldBeEscaped","some","jsxStopChar","preserveTrailingSpace","endsWith","startsWith","formatReactFragmentNode","TypeError","reactElementToJsxString","formatTree"],"mappings":";;;;;;;;;AAEA,cAAe,UAACA,KAAD,EAAgBC,OAAhB,EAA4C;MACrDD,UAAU,CAAd,EAAiB;WACR,EAAP;;;SAGK,IAAIE,KAAJ,CAAUF,QAAQC,OAAlB,EAA2BE,IAA3B,CAAgC,GAAhC,EAAqCC,IAArC,CAA0C,EAA1C,CAAP;CALF;;ACFA;;;;;;;AAOA,AAAe,SAAS,QAAQ,CAAC,GAAG,EAAE;EACpC,OAAO,GAAG,IAAI,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK,CAAC;CAC/E;;ACTD;;;;;;AAMA,AAEA;AACA,SAAS,cAAc,CAAC,CAAC,EAAE;EACzB,OAAO,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI;OACtB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,iBAAiB,CAAC;CAC9D;;AAED,AAAe,SAAS,aAAa,CAAC,CAAC,EAAE;EACvC,IAAI,IAAI,CAAC,IAAI,CAAC;;EAEd,IAAI,cAAc,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,OAAO,KAAK,CAAC;;;EAG9C,IAAI,GAAG,CAAC,CAAC,WAAW,CAAC;EACrB,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE,OAAO,KAAK,CAAC;;;EAG7C,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;EACtB,IAAI,cAAc,CAAC,IAAI,CAAC,KAAK,KAAK,EAAE,OAAO,KAAK,CAAC;;;EAGjD,IAAI,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,KAAK,KAAK,EAAE;IAClD,OAAO,KAAK,CAAC;GACd;;;EAGD,OAAO,IAAI,CAAC;CACb;;;;;;;;;;;;;AClCD,AACA,IAAI,QAAQ,GAAG,CAACC,cAAI,IAAIA,cAAI,CAAC,QAAQ,KAAK,YAAY;IAClD,QAAQ,GAAG,MAAM,CAAC,MAAM,IAAI,SAAS,CAAC,EAAE;QACpC,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YACjD,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACjB,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;gBAC3D,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;SACnB;QACD,OAAO,CAAC,CAAC;KACZ,CAAC;IACF,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;CAC1C,CAAC;AACF,IAAI,cAAc,GAAG,CAACA,cAAI,IAAIA,cAAI,CAAC,cAAc,KAAK,YAAY;IAC9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IACpF,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE;QAC5C,KAAK,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE;YAC7D,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACpB,OAAO,CAAC,CAAC;CACZ,CAAC;AACF,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AAC9D,IAAI,IAAI,GAAG,EAAE,CAAC;;;;;;;AAOd,SAAS,KAAK,CAAC,KAAK,EAAE;IAClB,IAAI,IAAI,GAAG,OAAO,KAAK,CAAC;IACxB,OAAO,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,QAAQ,IAAI,IAAI,KAAK,UAAU,CAAC,CAAC;CACvE;;;;;;;AAOD,SAAS,QAAQ,CAAC,KAAK,EAAE;IACrB,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,iBAAiB,CAAC;CACtE;;;;;;AAMD,SAAS,qBAAqB,CAAC,MAAM,EAAE;IACnC,OAAO,MAAM,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAU,SAAS,EAAE,EAAE,OAAO,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;CACtJ;;;;;;;;AAQD,SAAS,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,GAAG,EAAE;IACtC,IAAI,GAAG,KAAK,KAAK,CAAC,EAAE,EAAE,GAAG,GAAG,EAAE,CAAC,EAAE;;IAEjC,IAAI,cAAc,GAAG;QACjB,MAAM,EAAE,IAAI;QACZ,YAAY,EAAE,IAAI;KACrB,CAAC;IACF,IAAI,eAAe,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,cAAc,CAAC,EAAE,OAAO,CAAC,CAAC;IACtE,IAAI,MAAM,CAAC;IACX,IAAI,eAAe,CAAC,oBAAoB,KAAK,SAAS,EAAE;QACpD,MAAM,GAAG;YACL,OAAO,EAAE,IAAI;YACb,cAAc,EAAE,IAAI;YACpB,GAAG,EAAE,GAAG;YACR,MAAM,EAAE,GAAG,GAAG,eAAe,CAAC,MAAM;SACvC,CAAC;KACL;SACI;QACD,MAAM,GAAG;YACL,OAAO,EAAE,+BAA+B;YACxC,cAAc,EAAE,wCAAwC;YACxD,GAAG,EAAE,0BAA0B;YAC/B,MAAM,EAAE,6BAA6B;SACxC,CAAC;KACL;IACD,IAAI,gBAAgB,GAAG,UAAU,MAAM,EAAE;QACrC,IAAI,eAAe,CAAC,oBAAoB,KAAK,SAAS,EAAE;YACpD,OAAO,MAAM,CAAC;SACjB;QACD,IAAI,QAAQ,GAAG,MAAM;aAChB,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC;aAC5C,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC;aACpD,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;QACpE,IAAI,QAAQ,CAAC,MAAM,IAAI,eAAe,CAAC,oBAAoB,EAAE;YACzD,OAAO,QAAQ,CAAC;SACnB;QACD,OAAO,MAAM;aACR,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,GAAG,GAAG,GAAG,MAAM,CAAC,cAAc,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC;aAC5E,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC;aACzC,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;KAC9E,CAAC;IACF,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;QAC5B,OAAO,cAAc,CAAC;KACzB;IACD,IAAI,KAAK,KAAK,IAAI;QACd,KAAK,KAAK,SAAS;QACnB,OAAO,KAAK,KAAK,QAAQ;QACzB,OAAO,KAAK,KAAK,SAAS;QAC1B,OAAO,KAAK,KAAK,UAAU;QAC3B,OAAO,KAAK,KAAK,QAAQ;QACzB,QAAQ,CAAC,KAAK,CAAC,EAAE;QACjB,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;KACxB;IACD,IAAI,KAAK,YAAY,IAAI,EAAE;QACvB,OAAO,YAAY,GAAG,KAAK,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC;KACpD;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACtB,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACpB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjB,IAAI,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;YACxD,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,OAAO,GAAG,GAAG,GAAG,MAAM,CAAC,cAAc,CAAC;YAChF,IAAI,KAAK,GAAG,WAAW,CAAC,EAAE,EAAE,eAAe,EAAE,GAAG,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;YAC3E,IAAI,eAAe,CAAC,SAAS,EAAE;gBAC3B,KAAK,GAAG,eAAe,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;aACtD;YACD,OAAO,MAAM,CAAC,MAAM,GAAG,KAAK,GAAG,GAAG,CAAC;SACtC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;QAC/B,IAAI,CAAC,GAAG,EAAE,CAAC;QACX,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC;KAChC;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE;QACd,IAAI,SAAS,GAAG,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,qBAAqB,CAAC,KAAK,CAAC,EAAE,CAAC;QACnF,IAAI,eAAe,CAAC,MAAM,EAAE;YACxB,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,UAAU,EAAE,EAAE,EAAE,OAAO,eAAe,CAAC,MAAM,IAAI,eAAe,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;SACvH;QACD,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,OAAO,IAAI,CAAC;SACf;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjB,IAAI,GAAG,GAAG,GAAG,GAAG,MAAM,CAAC,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,UAAU,EAAE,EAAE,CAAC,EAAE;YAC5D,IAAI,GAAG,GAAG,SAAS,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,GAAG,MAAM,CAAC,OAAO,GAAG,GAAG,GAAG,MAAM,CAAC,cAAc,CAAC;YACpF,IAAI,QAAQ,GAAG,OAAO,EAAE,KAAK,QAAQ,CAAC;YACtC,IAAI,SAAS,GAAG,CAAC,QAAQ,IAAI,uBAAuB,CAAC,IAAI,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;YACzE,IAAI,GAAG,GAAG,QAAQ,IAAI,SAAS,GAAG,EAAE,GAAG,WAAW,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;YACxE,IAAI,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,eAAe,EAAE,GAAG,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;YAClF,IAAI,eAAe,CAAC,SAAS,EAAE;gBAC3B,KAAK,GAAG,eAAe,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;aACvD;YACD,OAAO,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,KAAK,GAAG,GAAG,CAAC;SAC3D,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;QAC/B,IAAI,CAAC,GAAG,EAAE,CAAC;QACX,OAAO,gBAAgB,CAAC,GAAG,CAAC,CAAC;KAChC;IACD,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,SAAS,EAAE,UAAU,CAAC,EAAE,EAAE,OAAO,CAAC,KAAK,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;IAC9F,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE;QAC/B,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACnC,OAAO,IAAI,GAAG,KAAK,GAAG,IAAI,CAAC;KAC9B;IACD,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IACvC,OAAO,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC;CAC5B;AACD,mBAAmB,GAAG,WAAW,CAAC;;;;;;;;;AC5JlC,AAAe,SAASC,UAAT,CAAoBC,KAApB,EAAqC;;MAE9CA,UAAU,IAAV,IAAkB,QAAOA,KAAP,yCAAOA,KAAP,OAAiB,QAAvC,EAAiD;WACxCA,KAAP;;;;MAIEA,iBAAiBC,IAAjB,IAAyBD,iBAAiBE,MAA9C,EAAsD;WAC7CF,KAAP;;;;MAIEL,MAAMQ,OAAN,CAAcH,KAAd,CAAJ,EAA0B;WACjBA,MAAMI,GAAN,CAAUL,UAAV,CAAP;;;;SAIKM,OAAOC,IAAP,CAAYN,KAAZ,EACJO,IADI,GAEJC,MAFI,CAEG,UAACC,MAAD,EAASC,GAAT,EAAiB;QACnBA,QAAQ,QAAZ,EAAsB;aACbD,MAAP;;QAEEC,QAAQ,SAAZ,EAAuB;;aAEdA,GAAP,IAAc,YAAd;KAFF,MAGO;;aAEEA,GAAP,IAAcX,WAAWC,MAAMU,GAAN,CAAX,CAAd;;WAEKD,MAAP;GAbG,EAcF,EAdE,CAAP;;;AClBF;;AAqCA,AAAO,IAAME,uBAAuB,SAAvBA,oBAAuB,CAACX,KAAD;SAAoC;UAChE,QADgE;;GAApC;CAA7B;;AAKP,AAAO,IAAMY,uBAAuB,SAAvBA,oBAAuB,CAACZ,KAAD;SAAoC;UAChE,QADgE;;GAApC;CAA7B;;AAKP,AAAO,IAAMa,6BAA6B,SAA7BA,0BAA6B,CACxCC,WADwC,EAExCC,KAFwC,EAGxCC,YAHwC,EAIxCC,SAJwC;SAKd;UACpB,cADoB;4BAAA;gBAAA;8BAAA;;GALc;CAAnC;;AAaP,AAAO,IAAMC,8BAA8B,SAA9BA,2BAA8B,CACzCR,GADyC,EAEzCO,SAFyC;SAGd;UACrB,eADqB;YAAA;;GAHc;CAApC;;;;;ACjDP,IAAME,kBAAkBC,QAAQC,cAAR,CAAxB;;AAEA,IAAMC,6BAA6B,SAA7BA,0BAA6B,CAACC,OAAD;SACjCA,QAAQC,IAAR,CAAaV,WAAb,IACAS,QAAQC,IAAR,CAAaC,IADb;SAEQF,QAAQC,IAAf,KAAwB,UAAxB;IACG,iBADH,GAEGD,QAAQC,IAJZ,CADiC;CAAnC;;AAOA,IAAME,aAAa,SAAbA,UAAa,CAACC,UAAD,EAAaC,QAAb;SAA0BA,aAAa,UAAvC;CAAnB;;AAEA,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAACC,QAAD;SAC7BA,aAAa,IAAb,IACAA,aAAa,KADb,IAEAA,aAAa,IAFb,IAGAA,aAAa,EAJgB;CAA/B;;AAMA,IAAMC,cAAc,SAAdA,WAAc,CAACC,aAAD,EAAoBC,EAApB,EAAqD;MACjEC,gBAAgB,EAAtB;;SAEO5B,IAAP,CAAY0B,aAAZ,EACGG,MADH,CACU;WAAOF,GAAGD,cAActB,GAAd,CAAH,EAAuBA,GAAvB,CAAP;GADV,EAEG0B,OAFH,CAEW;WAAQF,cAAcxB,GAAd,IAAqBsB,cAActB,GAAd,CAA7B;GAFX;;SAIOwB,aAAP;CAPF;;AAUA,IAAMG,oBAAoB,SAApBA,iBAAoB,CACxBd,OADwB,EAExBe,OAFwB,EAGX;6BACuDA,OADvD,CACLxB,WADK;MACQyB,aADR,wCACwBjB,0BADxB;;;MAGT,OAAOC,OAAP,KAAmB,QAAvB,EAAiC;WACxBZ,qBAAqBY,OAArB,CAAP;GADF,MAEO,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;WAC/BX,qBAAqBW,OAArB,CAAP;GADK,MAEA,IAAI,CAACiB,eAAMC,cAAN,CAAqBlB,OAArB,CAAL,EAAoC;UACnC,IAAImB,KAAJ,0EACmEnB,OADnE,2CACmEA,OADnE,SAAN;;;MAKIT,cAAcyB,cAAchB,OAAd,CAApB;;MAEMR,QAAQgB,YAAYR,QAAQR,KAApB,EAA2BW,UAA3B,CAAd;MACIH,QAAQoB,GAAR,KAAgB,IAApB,EAA0B;UAClBA,GAAN,GAAYpB,QAAQoB,GAApB;;;MAGIjC,MAAMa,QAAQb,GAApB;MACI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,IAAIkC,MAAJ,CAAW,KAAX,CAA/B,EAAkD;;UAE1ClC,GAAN,GAAYA,GAAZ;;;MAGIM,eAAee,YAAYR,QAAQC,IAAR,CAAaR,YAAb,IAA6B,EAAzC,EAA6CU,UAA7C,CAArB;MACMT,YAAYuB,eAAMK,QAAN,CAAeC,OAAf,CAAuBvB,QAAQR,KAAR,CAAce,QAArC,EACfK,MADe,CACRN,sBADQ,EAEfzB,GAFe,CAEX;WAASiC,kBAAkBU,KAAlB,EAAyBT,OAAzB,CAAT;GAFW,CAAlB;;MAIInB,mBAAmBI,QAAQC,IAAR,KAAiBH,cAAxC,EAAkD;WACzCH,4BAA4BR,GAA5B,EAAiCO,SAAjC,CAAP;;;SAGKJ,2BACLC,WADK,EAELC,KAFK,EAGLC,YAHK,EAILC,SAJK,CAAP;CAtCF;;ACrCA,SAAS+B,UAAT,GAAsB;;AAEtB,IAAaC,iBAAiB,SAAjBA,cAAiB,CAACC,EAAD;SAC5BA,GACGC,QADH,GAEGC,KAFH,CAES,IAFT,EAGGhD,GAHH,CAGO;WAAQiD,KAAKC,IAAL,EAAR;GAHP,EAIGzD,IAJH,CAIQ,EAJR,CAD4B;CAAvB;;AAOP,IAAa0D,4BAA4B,SAA5BA,yBAA4B,CAACL,EAAD;SAAqBA,GAAGC,QAAH,EAArB;CAAlC;;AAEP,IAAMK,uBAAuBP,cAA7B;;AAEA,sBAAe,UAACC,EAAD,EAAeZ,OAAf,EAA4C;8BACOA,OADP,CACjDmB,aADiD;MACjDA,aADiD,yCACjCD,oBADiC;MACXE,aADW,GACOpB,OADP,CACXoB,aADW;;MAErD,CAACA,aAAD,IAAkBD,kBAAkBD,oBAAxC,EAA8D;WACrDC,cAAcT,UAAd,CAAP;;;SAGKS,cAAcP,EAAd,CAAP;CANF;;ACJA,kCAAe,UACblD,KADa,EAEb2D,MAFa,EAGbC,GAHa,EAIbtB,OAJa,EAKF;MACLuB,kBAAkB9D,WAAWC,KAAX,CAAxB;;MAEM8D,mBAAmBC,OAAYF,eAAZ,EAA6B;eACzC,mBAACG,UAAD,EAAaC,IAAb,EAAmBC,cAAnB,EAAsC;UACzCC,eAAeH,WAAWC,IAAX,CAArB;;UAEIE,gBAAgB1B,qBAAe0B,YAAf,CAApB,EAAkD;eACzCC,eACL/B,kBAAkB8B,YAAlB,EAAgC7B,OAAhC,CADK,EAEL,IAFK,EAGLsB,GAHK,EAILtB,OAJK,CAAP;;;UAQE,OAAO6B,YAAP,KAAwB,UAA5B,EAAwC;eAC/BE,eAAeF,YAAf,EAA6B7B,OAA7B,CAAP;;;aAGK4B,cAAP;;GAjBqB,CAAzB;;MAqBIP,MAAJ,EAAY;WACHG,iBACJQ,OADI,CACI,MADJ,EACY,GADZ,EAEJA,OAFI,CAEI,KAFJ,EAEW,GAFX,EAGJA,OAHI,CAGI,KAHJ,EAGW,GAHX,EAIJA,OAJI,CAII,MAJJ,EAIY,GAJZ,EAKJA,OALI,CAKI,KALJ,EAKW,GALX,CAAP;;;;SASKR,iBACJQ,OADI,CACI,KADJ,EACWC,OAAO,CAAP,EAAUjC,QAAQ5C,OAAlB,CADX,EAEJ4E,OAFI,CAEI,WAFJ,SAEsBC,OAAOX,MAAM,CAAb,EAAgBtB,QAAQ5C,OAAxB,CAFtB,QAAP;CAvCF;;;;ACDA,IAAM8E,SAAS,SAATA,MAAS,CAACC,CAAD;SAAuBA,EAAEH,OAAF,CAAU,IAAV,EAAgB,QAAhB,CAAvB;CAAf;;AAEA,IAAMI,kBAAkB,SAAlBA,eAAkB,CACtBC,SADsB,EAEtBhB,MAFsB,EAGtBC,GAHsB,EAItBtB,OAJsB,EAKX;MACP,OAAOqC,SAAP,KAAqB,QAAzB,EAAmC;iBACtBC,OAAOD,SAAP,CAAX;;;MAGE,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;iBACtBH,OAAOG,SAAP,CAAX;;;;;;MAME,QAAOA,SAAP,2CAAOA,SAAP,OAAqB,QAAzB,EAAmC;QAC3BE,oBAAoBF,UACvBG,OADuB,GAEvB3B,QAFuB,GAGvBmB,OAHuB,CAGf,gBAHe,EAGG,IAHH,CAA1B;;QAKI,CAACO,iBAAL,EAAwB;;;;0BAILA,iBAAnB;;;MAGE,OAAOF,SAAP,KAAqB,UAAzB,EAAqC;iBACxBN,eAAeM,SAAf,EAA0BrC,OAA1B,CAAX;;;MAGEG,qBAAekC,SAAf,CAAJ,EAA+B;iBAClBP,eACT/B,kBAAkBsC,SAAlB,EAA6BrC,OAA7B,CADS,EAET,IAFS,EAGTsB,GAHS,EAITtB,OAJS,CAAX;;;MAQEqC,qBAAqB1E,IAAzB,EAA+B;2BACR0E,UAAUI,WAAV,EAArB;;;MAGEC,cAAcL,SAAd,KAA4BhF,MAAMQ,OAAN,CAAcwE,SAAd,CAAhC,EAA0D;iBAC7CM,2BAA2BN,SAA3B,EAAsChB,MAAtC,EAA8CC,GAA9C,EAAmDtB,OAAnD,CAAX;;;eAGSsC,OAAOD,SAAP,CAAX;CAnDF;;ACNA,kBAAe,UACblD,IADa,EAEbyD,QAFa,EAGblF,KAHa,EAIbmF,eAJa,EAKbC,YALa,EAMbzB,MANa,EAObC,GAPa,EAQbtB,OARa,EAaV;MACC,CAAC4C,QAAD,IAAa,CAACC,eAAlB,EAAmC;UAC3B,IAAIzC,KAAJ,gBACSjB,IADT,2DAAN;;;MAKI4D,YAAYH,WAAWlF,KAAX,GAAmBoF,YAArC;;MAEQE,yBATL,GAS4ChD,OAT5C,CASKgD,yBATL;MASgC5F,OAThC,GAS4C4C,OAT5C,CASgC5C,OAThC;;;MAWG6F,qBAAqBb,gBAAgBW,SAAhB,EAA2B1B,MAA3B,EAAmCC,GAAnC,EAAwCtB,OAAxC,CAA3B;;MAEIkD,2BAA2B,GAA/B;MACIC,qCAAmClB,OAAOX,MAAM,CAAb,EAAgBlE,OAAhB,CAAvC;MACMgG,uBAAuBH,mBAAmBI,QAAnB,CAA4B,IAA5B,CAA7B;;MAGEL,6BACAC,uBAAuB,SADvB,IAEA,CAACJ,eAHH,EAIE;;+BAE2B,EAA3B;kCAC8B,EAA9B;GAPF,MAQO,IAAIG,6BAA6BC,uBAAuB,QAAxD,EAAkE;qCACxC9D,IAA/B;wCACkCA,IAAlC;GAFK,MAGA;gCAC0BA,IAA/B,SAAuC8D,kBAAvC;mCACkC9D,IAAlC,SAA0C8D,kBAA1C;;;SAGK;sDAAA;4DAAA;;GAAP;CA9CF;;ACDA,8CAAe,UACbK,aADa,EAEbC,WAFa,EAGE;MACTC,QAAQF,cAAcG,KAAd,CACZ,CADY,EAEZH,cAAcI,MAAd,GAAuB,CAAvB,GAA2BJ,cAAcI,MAAd,GAAuB,CAAlD,GAAsD,CAF1C,CAAd;MAIMC,eAAeL,cAAcA,cAAcI,MAAd,GAAuB,CAArC,CAArB;;MAGEC,iBACCJ,YAAYrE,IAAZ,KAAqB,QAArB,IAAiCqE,YAAYrE,IAAZ,KAAqB,QADvD,MAECyE,aAAazE,IAAb,KAAsB,QAAtB,IAAkCyE,aAAazE,IAAb,KAAsB,QAFzD,CADF,EAIE;UACM0E,IAAN,CACEvF,qBACEiE,OAAOqB,aAAajG,KAApB,IAA6B4E,OAAOiB,YAAY7F,KAAnB,CAD/B,CADF;GALF,MAUO;QACDiG,YAAJ,EAAkB;YACVC,IAAN,CAAWD,YAAX;;;UAGIC,IAAN,CAAWL,WAAX;;;SAGKC,KAAP;CA5BF;;;;ACHA,IAAMK,kBAAkB,SAAlBA,eAAkB,CAACvE,QAAD;SAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe+D,QAAf,CAAwB/D,QAAxB,CAAtB;CAAxB;;AAEA,wBAAe,UAACwE,mBAAD;SAAkC,UAC/CrF,KAD+C,EAElC;QACPsF,cAActF,MAAM4E,QAAN,CAAe,KAAf,CAApB;QACMW,cAAcvF,MAAM4E,QAAN,CAAe,KAAf,CAApB;;QAEMY,gBAAgBxF,MAAMoB,MAAN,CAAa;aAAW,CAACgE,gBAAgBK,OAAhB,CAAZ;KAAb,CAAtB;;QAEMC,cAAcL,mDACZG,cAAchG,IAAd,EADY;mCAEZgG,aAFY,EAApB;;QAIID,WAAJ,EAAiB;kBACHI,OAAZ,CAAoB,KAApB;;;QAGEL,WAAJ,EAAiB;kBACHK,OAAZ,CAAoB,KAApB;;;WAGKD,WAAP;GApBa;CAAf;;ACMA,IAAME,8CAA8C,SAA9CA,2CAA8C,CAClDpF,OADkD,EAElDqF,gBAFkD,EAGlDjD,MAHkD,EAIlDC,GAJkD,EAKlDtB,OALkD,EAM/C;MACK5C,OADL,GACiB4C,OADjB,CACK5C,OADL;;;MAGC6B,QAAQC,IAAR,KAAiB,QAArB,EAA+B;WACtBoF,iBACJxD,KADI,CACE,IADF,EAEJhD,GAFI,CAEA,UAACiD,IAAD,EAAOwD,MAAP,EAAkB;UACjBA,WAAW,CAAf,EAAkB;eACTxD,IAAP;;;kBAGQkB,OAAOX,GAAP,EAAYlE,OAAZ,CAAV,GAAiC2D,IAAjC;KAPG,EASJxD,IATI,CASC,IATD,CAAP;;;SAYK+G,gBAAP;CAtBF;;AAyBA,IAAME,oBAAoB,SAApBA,iBAAoB,CACxBnD,MADwB,EAExBC,GAFwB,EAGxBtB,OAHwB;SAIrB;WACHqE,4CACEpF,OADF,EAEE6C,eAAe7C,OAAf,EAAwBoC,MAAxB,EAAgCC,GAAhC,EAAqCtB,OAArC,CAFF,EAGEqB,MAHF,EAIEC,GAJF,EAKEtB,OALF,CADG;GAJqB;CAA1B;;AAaA,IAAMyE,6BAA6B,SAA7BA,0BAA6B,CAAC/F,YAAD,EAAeD,KAAf;SAAyB,oBAAY;QAChEiG,mBAAmB3G,OAAOC,IAAP,CAAYU,YAAZ,EAA0B2E,QAA1B,CAAmC/D,QAAnC,CAAzB;WAEE,CAACoF,gBAAD,IACCA,oBAAoBhG,aAAaY,QAAb,MAA2Bb,MAAMa,QAAN,CAFlD;GAFiC;CAAnC;;AAQA,IAAMqF,2BAA2B,SAA3BA,wBAA2B,CAC/BC,UAD+B,EAE/BC,qBAF+B,EAG/BvD,GAH+B,EAI/BlE,OAJ+B,EAK/B0H,6BAL+B,EAMnB;MACR,CAACA,6BAAL,EAAoC;WAC3BF,WAAWlB,MAAX,GAAoB,CAA3B;;;SAIAzB,OAAOX,GAAP,EAAYlE,OAAZ,EAAqBsG,MAArB,GAA8BmB,sBAAsBnB,MAApD,GACAoB,6BAFF;CAXF;;AAiBA,IAAMC,4BAA4B,SAA5BA,yBAA4B,CAChCH,UADgC,EAEhCC,qBAFgC,EAGhCG,qBAHgC,EAIhC3D,MAJgC,EAKhCC,GALgC,EAMhClE,OANgC,EAOhC0H,6BAPgC;SAShC,CAACH,yBACCC,UADD,EAECC,qBAFD,EAGCvD,GAHD,EAIClE,OAJD,EAKC0H,6BALD,KAOCE,qBAPF,KAQA,CAAC3D,MAjB+B;CAAlC;;AAmBA,8BAAe,UACb4D,IADa,EAEb5D,MAFa,EAGbC,GAHa,EAIbtB,OAJa,EAKF;MAETd,IAFS,GAOP+F,IAPO,CAET/F,IAFS;0BAOP+F,IAPO,CAGTzG,WAHS;MAGTA,WAHS,qCAGK,EAHL;MAITG,SAJS,GAOPsG,IAPO,CAITtG,SAJS;oBAOPsG,IAPO,CAKTxG,KALS;MAKTA,KALS,+BAKD,EALC;2BAOPwG,IAPO,CAMTvG,YANS;MAMTA,YANS,sCAMM,EANN;;;MASPQ,SAAS,cAAb,EAA6B;UACrB,IAAIkB,KAAJ,mGAC4FlB,IAD5F,CAAN;;;MAMAO,WAhBS,GAqBPO,OArBO,CAgBTP,WAhBS;MAiBTqF,6BAjBS,GAqBP9E,OArBO,CAiBT8E,6BAjBS;MAkBTI,gBAlBS,GAqBPlF,OArBO,CAkBTkF,gBAlBS;MAmBTC,SAnBS,GAqBPnF,OArBO,CAmBTmF,SAnBS;MAoBT/H,OApBS,GAqBP4C,OArBO,CAoBT5C,OApBS;;;MAuBPgI,YAAU5G,WAAd;;MAEI6G,gBAAgBD,GAApB;MACIE,mBAAmBF,GAAvB;MACIJ,wBAAwB,KAA5B;;MAEMO,wBAAwB,EAA9B;;SAEOvH,IAAP,CAAYS,KAAZ,EACGoB,MADH,CACU;WAAYJ,YAAY+F,OAAZ,CAAoBlG,QAApB,MAAkC,CAAC,CAA/C;GADV,EAEGO,MAFH,CAEU4E,2BAA2B/F,YAA3B,EAAyCD,KAAzC,CAFV,EAGGqB,OAHH,CAGW;WAAYyF,sBAAsB3B,IAAtB,CAA2BtE,QAA3B,CAAZ;GAHX;;SAKOtB,IAAP,CAAYU,YAAZ,EACGmB,MADH,CACU;WAAmBJ,YAAY+F,OAAZ,CAAoBC,eAApB,MAAyC,CAAC,CAA7D;GADV,EAEG5F,MAFH,CAEU;WAAMqF,gBAAN;GAFV,EAGGrF,MAHH,CAGU;WAAmB,CAAC0F,sBAAsBlC,QAAtB,CAA+BoC,eAA/B,CAApB;GAHV,EAIG3F,OAJH,CAIW;WAAmByF,sBAAsB3B,IAAtB,CAA2B6B,eAA3B,CAAnB;GAJX;;MAMMb,aAAac,iBAAiBP,SAAjB,EAA4BI,qBAA5B,CAAnB;;aAEWzF,OAAX,CAAmB,yBAAiB;sBAK9B6F,WACFC,aADE,EAEF7H,OAAOC,IAAP,CAAYS,KAAZ,EAAmB4E,QAAnB,CAA4BuC,aAA5B,CAFE,EAGFnH,MAAMmH,aAAN,CAHE,EAIF7H,OAAOC,IAAP,CAAYU,YAAZ,EAA0B2E,QAA1B,CAAmCuC,aAAnC,CAJE,EAKFlH,aAAakH,aAAb,CALE,EAMFvE,MANE,EAOFC,GAPE,EAQFtB,OARE,CAL8B;QAEhCkD,wBAFgC,eAEhCA,wBAFgC;QAGhCC,2BAHgC,eAGhCA,2BAHgC;QAIhCC,oBAJgC,eAIhCA,oBAJgC;;QAgB9BA,oBAAJ,EAA0B;8BACA,IAAxB;;;qBAGeF,wBAAjB;wBACoBC,2BAApB;GArBF;;6BAwByBlB,OAAOX,GAAP,EAAYlE,OAAZ,CAAzB;;MAGE2H,0BACEH,UADF,EAEES,aAFF,EAGEL,qBAHF,EAIE3D,MAJF,EAKEC,GALF,EAMElE,OANF,EAOE0H,6BAPF,CADF,EAUE;UACMQ,gBAAN;GAXF,MAYO;UACCD,aAAN;;;MAGE1G,aAAaA,UAAU+E,MAAV,GAAmB,CAApC,EAAuC;QAC/BmC,SAASvE,MAAM,CAArB;;WAEO,GAAP;;QAEI,CAACD,MAAL,EAAa;aACJ,IAAP;aACOY,OAAO4D,MAAP,EAAezI,OAAf,CAAP;;;WAGKuB,UACJT,MADI,CACG4H,sCADH,EAC2C,EAD3C,EAEJhI,GAFI,CAEA0G,kBAAkBnD,MAAlB,EAA0BwE,MAA1B,EAAkC7F,OAAlC,CAFA,EAGJzC,IAHI,CAGC,CAAC8D,MAAD,UAAeY,OAAO4D,MAAP,EAAezI,OAAf,CAAf,GAA2C,EAH5C,CAAP;;QAKI,CAACiE,MAAL,EAAa;aACJ,IAAP;aACOY,OAAO4D,SAAS,CAAhB,EAAmBzI,OAAnB,CAAP;;kBAEUoB,WAAZ;GAnBF,MAoBO;QAEH,CAACmG,yBACCC,UADD,EAECS,aAFD,EAGC/D,GAHD,EAIClE,OAJD,EAKC0H,6BALD,CADH,EAQE;aACO,GAAP;;;WAGK,IAAP;;;SAGKM,GAAP;CA/HF;;ACjFA,IAAMW,uCAAuC,EAA7C;AACA,IAAMC,0CAA0C,gBAAhD;;AAEA,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAC7BzH,WAD6B,EAE7BJ,GAF6B,EAG7BO,SAH6B,EAIJ;MACrBF,QAAQ,EAAZ;MACIL,GAAJ,EAAS;YACC,EAAEA,QAAF,EAAR;;;SAGK;UACC,cADD;4BAAA;gBAAA;kBAIS,EAJT;;GAAP;CAVF;;AAmBA,IAAM8H,kBAAkB,SAAlBA,eAAkB;MAAG9H,GAAH,QAAGA,GAAH;SAAoCU,QAAQV,GAAR,CAApC;CAAxB;AACA,IAAM+H,gBAAgB,SAAhBA,aAAgB;MAAGxH,SAAH,SAAGA,SAAH;SACpBA,UAAU+E,MAAV,KAAqB,CADD;CAAtB;;AAGA,+BAAe,UACbuB,IADa,EAEb5D,MAFa,EAGbC,GAHa,EAIbtB,OAJa,EAKF;MACHd,IADG,GACsB+F,IADtB,CACH/F,IADG;MACGd,GADH,GACsB6G,IADtB,CACG7G,GADH;MACQO,SADR,GACsBsG,IADtB,CACQtG,SADR;;;MAGPO,SAAS,eAAb,EAA8B;UACtB,IAAIkB,KAAJ,oGAC6FlB,IAD7F,CAAN;;;MAKMkH,sBATG,GASwBpG,OATxB,CASHoG,sBATG;;;MAWP5H,oBAAJ;MACI4H,sBAAJ,EAA4B;QACtBD,cAAclB,IAAd,KAAuBiB,gBAAgBjB,IAAhB,CAA3B,EAAkD;oBAClCe,uCAAd;KADF,MAEO;oBACSD,oCAAd;;GAJJ,MAMO;kBACSC,uCAAd;;;SAGKK,uBACLJ,uBAAuBzH,WAAvB,EAAoCJ,GAApC,EAAyCO,SAAzC,CADK,EAEL0C,MAFK,EAGLC,GAHK,EAILtB,OAJK,CAAP;CA3BF;;AC9BA,IAAMsG,eAAe,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAArB;AACA,IAAMC,kBAAkB,SAAlBA,eAAkB,CAACpE,CAAD;SACtBmE,aAAaE,IAAb,CAAkB;WAAerE,EAAEkB,QAAF,CAAWoD,WAAX,CAAf;GAAlB,CADsB;CAAxB;;AAGA,IAAMvE,WAAS,SAATA,MAAS,CAACC,CAAD,EAAe;MACxB,CAACoE,gBAAgBpE,CAAhB,CAAL,EAAyB;WAChBA,CAAP;;;gBAGWA,CAAb;CALF;;AAQA,IAAMuE,wBAAwB,SAAxBA,qBAAwB,CAACvE,CAAD,EAAe;MACvChE,SAASgE,CAAb;MACIhE,OAAOwI,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;aACfxI,OAAO6D,OAAP,CAAe,cAAf,EAA+B,UAA/B,CAAT;;;MAGE7D,OAAOyI,UAAP,CAAkB,GAAlB,CAAJ,EAA4B;aACjBzI,OAAO6D,OAAP,CAAe,cAAf,EAA+B,UAA/B,CAAT;;;SAGK7D,MAAP;CAVF;;AAaA,sBAAe,UACb8G,IADa,EAEb5D,MAFa,EAGbC,GAHa,EAIbtB,OAJa,EAKF;MACPiF,KAAK/F,IAAL,KAAc,QAAlB,EAA4B;WACnBoD,OAAO2C,KAAKvH,KAAZ,CAAP;;;MAGEuH,KAAK/F,IAAL,KAAc,QAAlB,EAA4B;WACnB+F,KAAKvH,KAAL,QACAgJ,sBAAsBxE,SAAOI,OAAO2C,KAAKvH,KAAZ,CAAP,CAAtB,CADA,GAEH,EAFJ;;;MAKEuH,KAAK/F,IAAL,KAAc,cAAlB,EAAkC;WACzBmH,uBAAuBpB,IAAvB,EAA6B5D,MAA7B,EAAqCC,GAArC,EAA0CtB,OAA1C,CAAP;;;MAGEiF,KAAK/F,IAAL,KAAc,eAAlB,EAAmC;WAC1B2H,wBAAwB5B,IAAxB,EAA8B5D,MAA9B,EAAsCC,GAAtC,EAA2CtB,OAA3C,CAAP;;;QAGI,IAAI8G,SAAJ,0BAAqC7B,KAAK/F,IAA1C,OAAN;CAxBF;;AC1BA,kBAAe,UAAC+F,IAAD,EAAiBjF,OAAjB;SACb8B,eAAemD,IAAf,EAAqB,KAArB,EAA4B,CAA5B,EAA+BjF,OAA/B,CADa;CAAf;;ACCA,IAAM+G,0BAA0B,SAA1BA,uBAA0B,CAC9B9H,OAD8B,EAc3B;iFADU,EACV;8BAXDQ,WAWC;MAXDA,WAWC,oCAXa,EAWb;mCAVDyF,gBAUC;MAVDA,gBAUC,yCAVkB,IAUlB;gCATD9D,aASC;MATDA,aASC,sCATe,KASf;MARDD,aAQC,QARDA,aAQC;0BAPD/D,OAOC;MAPDA,OAOC,gCAPS,CAOT;mCAND4F,yBAMC;MANDA,yBAMC,yCAN2B,IAM3B;mCALDoD,sBAKC;MALDA,sBAKC,yCALwB,IAKxB;4BAJDjB,SAIC;MAJDA,SAIC,kCAJW,IAIX;MAHDL,6BAGC,QAHDA,6BAGC;MAFDtG,WAEC,QAFDA,WAEC;;MACC,CAACS,OAAL,EAAc;UACN,IAAImB,KAAJ,CAAU,sDAAV,CAAN;;;MAGIJ,UAAU;4BAAA;sCAAA;gCAAA;gCAAA;oBAAA;wDAAA;kDAAA;wBAAA;gEAAA;;GAAhB;;SAaOgH,WAAWjH,kBAAkBd,OAAlB,EAA2Be,OAA3B,CAAX,EAAgDA,OAAhD,CAAP;CAhCF;;;;;;"}