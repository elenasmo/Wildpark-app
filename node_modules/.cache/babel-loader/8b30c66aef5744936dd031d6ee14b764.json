{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.memoizerific = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      module.exports = function (forceSimilar) {\n        if (typeof Map !== 'function' || forceSimilar) {\n          var Similar = _dereq_('./similar');\n\n          return new Similar();\n        } else {\n          return new Map();\n        }\n      };\n    }, {\n      \"./similar\": 2\n    }],\n    2: [function (_dereq_, module, exports) {\n      function Similar() {\n        this.list = [];\n        this.lastItem = undefined;\n        this.size = 0;\n        return this;\n      }\n\n      Similar.prototype.get = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          return this.lastItem.val;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          return this.list[index].val;\n        }\n\n        return undefined;\n      };\n\n      Similar.prototype.set = function (key, val) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          this.lastItem.val = val;\n          return this;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          this.list[index].val = val;\n          return this;\n        }\n\n        this.lastItem = {\n          key: key,\n          val: val\n        };\n        this.list.push(this.lastItem);\n        this.size++;\n        return this;\n      };\n\n      Similar.prototype.delete = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          this.lastItem = undefined;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.size--;\n          return this.list.splice(index, 1)[0];\n        }\n\n        return undefined;\n      }; // important that has() doesn't use get() in case an existing key has a falsy value, in which case has() would return false\n\n\n      Similar.prototype.has = function (key) {\n        var index;\n\n        if (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n          return true;\n        }\n\n        index = this.indexOf(key);\n\n        if (index >= 0) {\n          this.lastItem = this.list[index];\n          return true;\n        }\n\n        return false;\n      };\n\n      Similar.prototype.forEach = function (callback, thisArg) {\n        var i;\n\n        for (i = 0; i < this.size; i++) {\n          callback.call(thisArg || this, this.list[i].val, this.list[i].key, this);\n        }\n      };\n\n      Similar.prototype.indexOf = function (key) {\n        var i;\n\n        for (i = 0; i < this.size; i++) {\n          if (this.isEqual(this.list[i].key, key)) {\n            return i;\n          }\n        }\n\n        return -1;\n      }; // check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\n\n\n      Similar.prototype.isEqual = function (val1, val2) {\n        return val1 === val2 || val1 !== val1 && val2 !== val2;\n      };\n\n      module.exports = Similar;\n    }, {}],\n    3: [function (_dereq_, module, exports) {\n      var MapOrSimilar = _dereq_('map-or-similar');\n\n      module.exports = function (limit) {\n        var cache = new MapOrSimilar(undefined === 'true'),\n            lru = [];\n        return function (fn) {\n          var memoizerific = function () {\n            var currentCache = cache,\n                newMap,\n                fnResult,\n                argsLengthMinusOne = arguments.length - 1,\n                lruPath = Array(argsLengthMinusOne + 1),\n                isMemoized = true,\n                i;\n\n            if ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {\n              throw new Error('Memoizerific functions should always be called with the same number of arguments');\n            } // loop through each argument to traverse the map tree\n\n\n            for (i = 0; i < argsLengthMinusOne; i++) {\n              lruPath[i] = {\n                cacheItem: currentCache,\n                arg: arguments[i]\n              }; // climb through the hierarchical map tree until the second-last argument has been found, or an argument is missing.\n              // if all arguments up to the second-last have been found, this will potentially be a cache hit (determined later)\n\n              if (currentCache.has(arguments[i])) {\n                currentCache = currentCache.get(arguments[i]);\n                continue;\n              }\n\n              isMemoized = false; // make maps until last value\n\n              newMap = new MapOrSimilar(undefined === 'true');\n              currentCache.set(arguments[i], newMap);\n              currentCache = newMap;\n            } // we are at the last arg, check if it is really memoized\n\n\n            if (isMemoized) {\n              if (currentCache.has(arguments[argsLengthMinusOne])) {\n                fnResult = currentCache.get(arguments[argsLengthMinusOne]);\n              } else {\n                isMemoized = false;\n              }\n            }\n\n            if (!isMemoized) {\n              fnResult = fn.apply(null, arguments);\n              currentCache.set(arguments[argsLengthMinusOne], fnResult);\n            }\n\n            if (limit > 0) {\n              lruPath[argsLengthMinusOne] = {\n                cacheItem: currentCache,\n                arg: arguments[argsLengthMinusOne]\n              };\n\n              if (isMemoized) {\n                moveToMostRecentLru(lru, lruPath);\n              } else {\n                lru.push(lruPath);\n              }\n\n              if (lru.length > limit) {\n                removeCachedResult(lru.shift());\n              }\n            }\n\n            memoizerific.wasMemoized = isMemoized;\n            memoizerific.numArgs = argsLengthMinusOne + 1;\n            return fnResult;\n          };\n\n          memoizerific.limit = limit;\n          memoizerific.wasMemoized = false;\n          memoizerific.cache = cache;\n          memoizerific.lru = lru;\n          return memoizerific;\n        };\n      }; // move current args to most recent position\n\n\n      function moveToMostRecentLru(lru, lruPath) {\n        var lruLen = lru.length,\n            lruPathLen = lruPath.length,\n            isMatch,\n            i,\n            ii;\n\n        for (i = 0; i < lruLen; i++) {\n          isMatch = true;\n\n          for (ii = 0; ii < lruPathLen; ii++) {\n            if (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {\n              isMatch = false;\n              break;\n            }\n          }\n\n          if (isMatch) {\n            break;\n          }\n        }\n\n        lru.push(lru.splice(i, 1)[0]);\n      } // remove least recently used cache item and all dead branches\n\n\n      function removeCachedResult(removedLru) {\n        var removedLruLen = removedLru.length,\n            currentLru = removedLru[removedLruLen - 1],\n            tmp,\n            i;\n        currentLru.cacheItem.delete(currentLru.arg); // walk down the tree removing dead branches (size 0) along the way\n\n        for (i = removedLruLen - 2; i >= 0; i--) {\n          currentLru = removedLru[i];\n          tmp = currentLru.cacheItem.get(currentLru.arg);\n\n          if (!tmp || !tmp.size) {\n            currentLru.cacheItem.delete(currentLru.arg);\n          } else {\n            break;\n          }\n        }\n      } // check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\n\n\n      function isEqual(val1, val2) {\n        return val1 === val2 || val1 !== val1 && val2 !== val2;\n      }\n    }, {\n      \"map-or-similar\": 1\n    }]\n  }, {}, [3])(3);\n});","map":null,"metadata":{},"sourceType":"script"}